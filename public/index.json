[{"categories":["oc"],"content":"Are you ready to containerize your web application effortlessly? Docker provides a convenient solution to package your application into a portable, isolated environment, ensuring consistency across different platforms. In this guide, we’ll walk through the steps to dockerize your web application using a simple example project. ","date":"2024-03-15","objectID":"/posts/docker-101/:0:0","tags":["Docker","Web Development","DevOps"],"title":"Docker - 101","uri":"/posts/docker-101/"},{"categories":["oc"],"content":"Set Up the Environment Before diving into Dockerizing your web app, ensure you have Docker installed on your system. You can verify this by running the following command in your terminal: docker --version If Docker is not installed, you can download and install it from the official Docker website. Next, clone or download the web application project from the Git repository: git clone https://github.com/M-Enes/todo-app.git ","date":"2024-03-15","objectID":"/posts/docker-101/:0:1","tags":["Docker","Web Development","DevOps"],"title":"Docker - 101","uri":"/posts/docker-101/"},{"categories":["oc"],"content":"Create a Dockerfile Once you have the project on your local machine, navigate to the project directory and create a Dockerfile: cd \u003cproject_directory\u003e touch Dockerfile Open the Dockerfile using a text editor and define the image: # Use an existing base image FROM nginx:latest # Copy the web application files to the container COPY . /usr/share/nginx/html ","date":"2024-03-15","objectID":"/posts/docker-101/:0:2","tags":["Docker","Web Development","DevOps"],"title":"Docker - 101","uri":"/posts/docker-101/"},{"categories":["oc"],"content":"Build the Docker Image With the Dockerfile in place, it’s time to build the Docker image using the following command: docker build -t my-web-app . ","date":"2024-03-15","objectID":"/posts/docker-101/:0:3","tags":["Docker","Web Development","DevOps"],"title":"Docker - 101","uri":"/posts/docker-101/"},{"categories":["oc"],"content":"Run the Docker Container Once the image is built, you can run the Docker container from the image: docker run -d -p 8080:80 my-web-app To ensure the container is running, you can check its status with: docker ps ","date":"2024-03-15","objectID":"/posts/docker-101/:0:4","tags":["Docker","Web Development","DevOps"],"title":"Docker - 101","uri":"/posts/docker-101/"},{"categories":["oc"],"content":"Test the Dockerized Web Application Open a web browser and navigate to http://localhost:8080 to access the web application. Interact with the application to ensure it functions correctly within the Docker container. ","date":"2024-03-15","objectID":"/posts/docker-101/:0:5","tags":["Docker","Web Development","DevOps"],"title":"Docker - 101","uri":"/posts/docker-101/"},{"categories":["oc"],"content":"Publish the Docker Image (Optional) If you wish to share your Docker image with others or deploy it to a production environment, you can publish it to Docker Hub. First, log in to Docker Hub: docker login Then, tag the Docker image with your Docker Hub username and repository name: docker tag my-web-app \u003cusername\u003e/\u003crepository_name\u003e:\u003ctag\u003e Finally, push the Docker image to Docker Hub: docker push \u003cusername\u003e/\u003crepository_name\u003e:\u003ctag\u003e ","date":"2024-03-15","objectID":"/posts/docker-101/:0:6","tags":["Docker","Web Development","DevOps"],"title":"Docker - 101","uri":"/posts/docker-101/"},{"categories":["oc"],"content":"Cleanup After you’re done testing or publishing your Docker image, it’s good practice to clean up by stopping and removing the running container: docker stop \u003ccontainer_id\u003e docker rm \u003ccontainer_id\u003e You can also delete the Docker image if it’s no longer needed: docker rmi my-web-app By following these steps, you’ve successfully Dockerized your web application, making it more portable, scalable, and easier to manage across different environments. Happy containerizing! ","date":"2024-03-15","objectID":"/posts/docker-101/:0:7","tags":["Docker","Web Development","DevOps"],"title":"Docker - 101","uri":"/posts/docker-101/"},{"categories":["oc"],"content":"Welcome to our comprehensive guide on Dockerized microservices architecture! In this tutorial, we’ll take a deep dive into setting up a microservices architecture using Docker Compose, complete with detailed code examples for each microservice. ","date":"2024-03-15","objectID":"/posts/docker-102/:0:0","tags":["Docker","Web Development","DevOps"],"title":"Docker - 102","uri":"/posts/docker-102/"},{"categories":["oc"],"content":"Set Up the Environment Before we dive into Docker Compose, ensure you have it installed on your system: docker-compose --version Create a project directory for our microservices architecture: mkdir docker_microservices cd docker_microservices ","date":"2024-03-15","objectID":"/posts/docker-102/:0:1","tags":["Docker","Web Development","DevOps"],"title":"Docker - 102","uri":"/posts/docker-102/"},{"categories":["oc"],"content":"Create Docker Compose YAML File Start by creating a docker-compose.yml file in the project directory: touch docker-compose.yml ","date":"2024-03-15","objectID":"/posts/docker-102/:0:2","tags":["Docker","Web Development","DevOps"],"title":"Docker - 102","uri":"/posts/docker-102/"},{"categories":["oc"],"content":"Develop Microservices For our demonstration, we’ll have two microservices: app1 and app2, both built using Flask. app1 Microservice Dockerfile: ./app1/Dockerfile # Use the official Python image as base FROM python:3.9-slim # Set the working directory in the container WORKDIR /app # Copy the current directory contents into the container at /app COPY . /app # Install Flask and requests library RUN pip install Flask requests # Set environment variables ENV FLASK_APP=app1.py ENV FLASK_RUN_HOST=0.0.0.0 # Expose port 5001 EXPOSE 5001 # Run the Flask application CMD [\"python\", \"app1.py\"] Application code: ./app1/app1.py from flask import Flask, jsonify import requests app = Flask(__name__) @app.route('/') def index(): response = requests.get('http://app2:5002') return jsonify(message=\"App1 received response from App2\", app2_response=response.json()) if __name__ == '__main__': app.run(host='0.0.0.0', port=5001) app2 Microservice Dockerfile: ./app2/Dockerfile # Use the official Python image as base FROM python:3.9-slim # Set the working directory in the container WORKDIR /app # Copy the current directory contents into the container at /app COPY . /app # Install Flask RUN pip install Flask # Set environment variables ENV FLASK_APP=app2.py ENV FLASK_RUN_HOST=0.0.0.0 # Expose port 5002 EXPOSE 5002 # Run the Flask application CMD [\"python\", \"app2.py\"] Application code: ./app2/app2.py from flask import Flask, jsonify app = Flask(__name__) @app.route('/') def index(): return jsonify(message=\"Hello from App2!\") if __name__ == '__main__': app.run(host='0.0.0.0', port=5002) ","date":"2024-03-15","objectID":"/posts/docker-102/:0:3","tags":["Docker","Web Development","DevOps"],"title":"Docker - 102","uri":"/posts/docker-102/"},{"categories":["oc"],"content":"Define Docker Compose Services Now, let’s define the services for each microservice in the docker-compose.yml file: version: '3' services: app1: build: ./app1 ports: - \"5001:5001\" networks: - my_network app2: build: ./app2 networks: - my_network networks: my_network: driver: bridge ","date":"2024-03-15","objectID":"/posts/docker-102/:0:4","tags":["Docker","Web Development","DevOps"],"title":"Docker - 102","uri":"/posts/docker-102/"},{"categories":["oc"],"content":"Build and Run the Application It’s time to build and run our microservices application using Docker Compose: docker-compose up --build -d Verify that all services are running without errors: docker-compose ps ","date":"2024-03-15","objectID":"/posts/docker-102/:0:5","tags":["Docker","Web Development","DevOps"],"title":"Docker - 102","uri":"/posts/docker-102/"},{"categories":["oc"],"content":"Test the Application Test the functionality of the application by sending requests to the exposed endpoints of each microservice. Ensure that data is being exchanged between microservices correctly. ","date":"2024-03-15","objectID":"/posts/docker-102/:0:6","tags":["Docker","Web Development","DevOps"],"title":"Docker - 102","uri":"/posts/docker-102/"},{"categories":["oc"],"content":"Scale Services (Optional) If you want to demonstrate scaling of services, you can use Docker Compose: docker-compose scale \u003cservice_name\u003e=\u003cnumber_of_instances\u003e ","date":"2024-03-15","objectID":"/posts/docker-102/:0:7","tags":["Docker","Web Development","DevOps"],"title":"Docker - 102","uri":"/posts/docker-102/"},{"categories":["oc"],"content":"Volume Mounting and Persistent Data Storage Modify the docker-compose.yml file to include volume mounts for persistent data storage. This ensures that data persists even after containers are stopped and restarted. ","date":"2024-03-15","objectID":"/posts/docker-102/:0:8","tags":["Docker","Web Development","DevOps"],"title":"Docker - 102","uri":"/posts/docker-102/"},{"categories":["oc"],"content":"Cleanup Once you’re done, stop and remove all containers created by Docker Compose: docker-compose down Conclusion: In this tutorial, we’ve explored Dockerized microservices architecture in depth, covering Docker Compose, multi-container applications, networking, volume mounting for persistent data storage, scalability, and more. Dockerized microservices offer flexibility, scalability, and easy management, making them a powerful choice for modern applications. Now that you’ve mastered Dockerized microservices, feel free to explore more advanced Docker features and architectures. Happy containerizing! Welcome to the world of Dockerized microservices architecture! In this guide, we’ll walk you through setting up a microservices architecture using Docker Compose, creating multiple services, communicating between them, and ensuring scalability and persistence. ","date":"2024-03-15","objectID":"/posts/docker-102/:0:9","tags":["Docker","Web Development","DevOps"],"title":"Docker - 102","uri":"/posts/docker-102/"},{"categories":["oc"],"content":"Buiding a Pipeline Using Containers This exercise demonstrates how to build a pipeline composed of independent containers whose goal is to train a machine learning model on-demand. The workflow ","date":"2024-03-15","objectID":"/posts/docker-103/:0:0","tags":["Docker","Web Development","DevOps"],"title":"Docker - 103","uri":"/posts/docker-103/"},{"categories":["oc"],"content":"Dockerfile for app Path: ./app/Dockerfile # Use the official Python image as base FROM python:3.9-slim # Install Flask RUN pip install Flask requests # Set the working directory in the container WORKDIR /app # Copy the current directory contents into the container at /app COPY . /app # Expose port 5000 EXPOSE 5000 # Run the Flask application CMD [\"python\", \"app.py\"] Explanation: This Dockerfile starts with the official Python image and installs Flask along with the requests library. It sets the working directory inside the container as /app. Copies all files from the current directory (.) into the container’s /app directory. Exposes port 5000 to allow communication with the Flask application. Finally, it specifies the command to run the Flask application using CMD. ","date":"2024-03-15","objectID":"/posts/docker-103/:0:1","tags":["Docker","Web Development","DevOps"],"title":"Docker - 103","uri":"/posts/docker-103/"},{"categories":["oc"],"content":"Python Script for app Path: ./app/app.py from flask import Flask, jsonify import requests app = Flask(__name__) @app.route('/') def index(): response = requests.get('http://train:5000') return jsonify(message=\"App received response from Train\", train_response=response.json()) if __name__ == '__main__': app.run(host='0.0.0.0', port=5000) Explanation: This Python script defines a Flask application. It creates a route / which sends a request to the train service at port 5000. Upon receiving the response, it returns a JSON message indicating receipt of the response from Train. ","date":"2024-03-15","objectID":"/posts/docker-103/:0:2","tags":["Docker","Web Development","DevOps"],"title":"Docker - 103","uri":"/posts/docker-103/"},{"categories":["oc"],"content":"Dockerfile for preprocess Path: ./preprocess/Dockerfile # Use the official Python image as base FROM python:3.9-slim # Install Flask RUN pip install Flask mysql-connector-python # Set the working directory in the container WORKDIR /app # Copy the current directory contents into the container at /app COPY . /app # Expose port 5000 EXPOSE 5000 # Run the Flask application CMD [\"python\", \"app.py\"] Explanation: Similar to the app Dockerfile, this one installs Flask along with mysql-connector-python. It sets the working directory as /app and copies all files into it. Exposes port 5000 for communication. Specifies the command to run the Flask application. ","date":"2024-03-15","objectID":"/posts/docker-103/:0:3","tags":["Docker","Web Development","DevOps"],"title":"Docker - 103","uri":"/posts/docker-103/"},{"categories":["oc"],"content":"Python Script for preprocess Path: ./preprocess/app.py from flask import Flask, jsonify import mysql.connector app = Flask(__name__) # Database connection configuration db_config = { 'host': 'db', # Service name in Docker Compose network 'user': 'my_user', 'password': 'my_password', 'database': 'train_database' } # Function to fetch data from the database def get_data(): try: connection = mysql.connector.connect(**db_config) cursor = connection.cursor() cursor.execute('SELECT * FROM trains') data = cursor.fetchall() print(data) return data except mysql.connector.Error as error: return f\"Error: {error}\" finally: if connection.is_connected(): cursor.close() connection.close() @app.route('/') def index(): # Fetch data from the database data = get_data() data_json = { \"data\": data } return jsonify(message=\"Preprocess received response from Database\", database_response=data_json) if __name__ == '__main__': app.run(host='0.0.0.0', port=5000) Explanation: This script sets up a Flask application. It defines a route / which connects to the database (db) to fetch data from the trains table. The fetched data is returned as a JSON response. ","date":"2024-03-15","objectID":"/posts/docker-103/:0:4","tags":["Docker","Web Development","DevOps"],"title":"Docker - 103","uri":"/posts/docker-103/"},{"categories":["oc"],"content":"README File Path: ./README.md # Building a Pipeline Using Containers This exercise demonstrates how to build a pipeline composed of independent containers whose goal is to train a machine learning model on-demand. **TODO:** - [ ] Load CSV file data from OpenML into a MySQL database. - [ ] Develop a preprocessing process. - [ ] Develop a training process. - [ ] The app should be a Gradio application with an interface and the ability to preview data from the database. Explanation: This Markdown file outlines the purpose of the project and lists tasks to be completed. ","date":"2024-03-15","objectID":"/posts/docker-103/:0:5","tags":["Docker","Web Development","DevOps"],"title":"Docker - 103","uri":"/posts/docker-103/"},{"categories":["oc"],"content":"Dockerfile for train Path: ./train/Dockerfile # Use the official Python image as base FROM python:3.9-slim # Install Flask RUN pip install Flask requests # Set the working directory in the container WORKDIR /app # Copy the current directory contents into the container at /app COPY . /app # Expose port 5000 EXPOSE 5000 # Run the Flask application CMD [\"python\", \"app.py\"] Explanation: Similar to the previous Dockerfiles, this one installs Flask and sets up the working directory. Exposes port 5000 for communication with the Flask application. ","date":"2024-03-15","objectID":"/posts/docker-103/:0:6","tags":["Docker","Web Development","DevOps"],"title":"Docker - 103","uri":"/posts/docker-103/"},{"categories":["oc"],"content":"Python Script for train Path: ./train/app.py from flask import Flask, jsonify import requests app = Flask(__name__) @app.route('/') def index(): response = requests.get('http://preprocess:5000') return jsonify(message=\"Train received response from Preprocess\", preprocess_response=response.json()) if __name__ == '__main__': app.run(host='0.0.0.0', port=5000) Explanation: This script defines a Flask application. It creates a route / which sends a request to the preprocess service at port 5000. Upon receiving the response, it returns a JSON message indicating receipt of the response from Preprocess. ","date":"2024-03-15","objectID":"/posts/docker-103/:0:7","tags":["Docker","Web Development","DevOps"],"title":"Docker - 103","uri":"/posts/docker-103/"},{"categories":["oc"],"content":"Dockerfile for ` db` Path: ./db/Dockerfile # Use the official MySQL image as base FROM mysql:8.3.0 # Copy the SQL script to create the table into the container COPY init.sql /docker-entrypoint-initdb.d/ Explanation: This Dockerfile sets up the MySQL database container. It uses the official MySQL image and copies the SQL script for table creation into the container’s initialization directory. ","date":"2024-03-15","objectID":"/posts/docker-103/:0:8","tags":["Docker","Web Development","DevOps"],"title":"Docker - 103","uri":"/posts/docker-103/"},{"categories":["oc"],"content":"SQL Script for Initializing db Path: ./db/init.sql -- Create the database if it doesn't exist CREATE DATABASE IF NOT EXISTS train_database; -- Use the created database USE train_database; -- Create table for trains CREATE TABLE IF NOT EXISTS trains ( train_id INT AUTO_INCREMENT PRIMARY KEY, train_name VARCHAR(255) NOT NULL, departure_time INT NOT NULL, arrival_time INT NOT NULL, departure_station VARCHAR(100) NOT NULL, arrival_station VARCHAR(100) NOT NULL ); -- Generate and insert sample train data INSERT INTO trains (train_name, departure_time, arrival_time, departure_station, arrival_station) SELECT CONCAT('Train ', numbers.n) AS train_name, FLOOR(RAND() * 86400) AS departure_time, FLOOR(RAND() * 86400) AS arrival_time, CONCAT('Station ', FLOOR(RAND() * 1000)) AS departure_station, CONCAT('Station ', FLOOR(RAND() * 1000)) AS arrival_station FROM ( SELECT (a.n + b.n * 10 + c.n * 100) AS n FROM (SELECT 0 AS n UNION ALL SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4 UNION ALL SELECT 5 UNION ALL SELECT 6 UNION ALL SELECT 7 UNION ALL SELECT 8 UNION ALL SELECT 9) AS a, (SELECT 0 AS n UNION ALL SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4 UNION ALL SELECT 5 UNION ALL SELECT 6 UNION ALL SELECT 7 UNION ALL SELECT 8 UNION ALL SELECT 9) AS b, (SELECT 0 AS n UNION ALL SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4 UNION ALL SELECT 5 UNION ALL SELECT 6 UNION ALL SELECT 7 UNION ALL SELECT 8 UNION ALL SELECT 9) AS c ) AS numbers LIMIT 1000; Explanation: This SQL script initializes the MySQL database. It creates a database named train_database if it doesn’t exist and switches to it. Then it creates a table trains with columns for train details. Finally, it generates and inserts sample train data into the table. ","date":"2024-03-15","objectID":"/posts/docker-103/:0:9","tags":["Docker","Web Development","DevOps"],"title":"Docker - 103","uri":"/posts/docker-103/"},{"categories":["oc"],"content":"Docker Compose Configuration Path: ./docker-compose.yml version: '3' services: app: build: ./app ports: - \"5001:5000\" networks: - my_network train: build: ./train networks: - my_network preprocess: build: ./preprocess networks: - my_network db: build: ./db environment: MYSQL_ROOT_PASSWORD: root_password MYSQL_DATABASE: train_database MYSQL_USER: my_user MYSQL_PASSWORD: my_password networks: - my_network volumes: - db_data:/var/lib/mysql networks: my_network: driver: bridge volumes: db_data: Explanation: This YAML file defines a multi-container environment using Docker Compose. It specifies services for app, train, preprocess, and db. Each service is built from its respective Dockerfile. The db service also configures environment variables for MySQL and mounts a volume for persistent data storage. All services are connected to a custom network named my_network. This comprehensive setup allows you to build and deploy a pipeline using Docker containers. Each component is modularized and can be scaled or modified independently to suit your requirements. Feel free to reach out if you have any questions or need further assistance! ","date":"2024-03-15","objectID":"/posts/docker-103/:0:10","tags":["Docker","Web Development","DevOps"],"title":"Docker - 103","uri":"/posts/docker-103/"},{"categories":null,"content":"This is my first post! Hello world! ","date":"2023-04-13","objectID":"/posts/first-post/:0:0","tags":null,"title":"First Post","uri":"/posts/first-post/"}]